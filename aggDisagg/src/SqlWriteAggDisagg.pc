/*****************************************************************************
* DESCRIPTION
*
* This file contains the functions which load the aggregated/disaggregated
* data into the database.
*
***************************************
*
* SqlWriteRealAggDisagg
*
* Purpose: insert/update real data values in database
* 
* Input
*      RUN_CONTROL    -- structure holding info to drive application
*      ID             -- site datatype ID of data to be written
*      VALUE_RECORD*  -- array of values to be written
*      int            -- number of values
*
* Output
*
* Return
* 	int - OK or ERROR
*
* Carol Marra
* April, 1996
****************************************************************************/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "aggDisagg.h"
#include "aggDisaggDefines.h"
#include "utils.h"
#include "dbutils.h"
#include "defines.h"
#include "typedefs.h"
#include "aggDisaggTypedefs.h"

EXEC SQL INCLUDE sqlca;

#define FUNC_NAME "SqlWriteRealAggDisagg"

int SqlWriteRealAggDisagg (RUN_CONTROL runControl, ID siteDatatypeId,
			   VALUE_RECORD *disAggValueList, int numDisAggValues)

{
  EXEC SQL BEGIN DECLARE SECTION;
    SQL_DATE      date1;
    SQL_DATE      date2;
    int           index1;
    int           index2;
    double        value;
    char          insertStatement[1000];
    char          updateStatement[1000];
    ID            sdi = siteDatatypeId;
 EXEC SQL END DECLARE SECTION;

  int         valueCount,
              result;
  char        validationFlag[2],
              dateColumn[30],
              valuesStatement[200],
              whereStatement[200];
  
  /* Get the validation flag for this site/datatype */
  if ((result = SqlGetValidationFlag (sdi, validationFlag)) != OK)
    {
      return (ERROR);
    }

  /* Set date column based on destination interval. */
  if ((result = GetDateColumn (runControl.obsDest, runControl.isStat,
			       runControl.destIsRange, dateColumn)) != OK)
    {
      PrintError ("%s: Exiting.\n", FUNC_NAME);
      return (ERROR);
    }

  if (!runControl.destIsRange)
    {
      if (runControl.isStat)
      {
	sprintf (valuesStatement, 
		 "VALUES (%d, :a, :b, %d)",
		 siteDatatypeId, runControl.modelOrSourceId);
	sprintf (whereStatement, "%s = :d", dateColumn);
      }
      else
      {
	 sprintf (valuesStatement, 
		  "VALUES (%d, '%s', to_date (:a, 'dd-mon-yyyy hh24:mi:ss'), to_date (:b, 'dd-mon-yyyy hh24:mi:ss'), :c, %d, '%s', SYSDATE, '%s', %d, %d, %d, %d)",
		  siteDatatypeId, runControl.interval, 
		  runControl.agencyId, runControl.overwriteFlag,
		  validationFlag, runControl.collectionSystemId, 
		  runControl.loadingApplicationId, runControl.methodId,
		  runControl.computationId);
	 sprintf (whereStatement, "start_%s = to_date (:d, 'dd-mon-yyyy hh24:mi:ss') AND end_%s = to_date (:e, 'dd-mon-yyyy hh24:mi:ss') AND interval = '%s'" ,
		  dateColumn, dateColumn, runControl.interval);
      }
    }
  else
    {
      if (runControl.isStat)
      {
	 sprintf (valuesStatement, 
		  "VALUES (%d, :a, :b, :c, %d)",
		  siteDatatypeId, runControl.modelOrSourceId);
	 sprintf (whereStatement, 
		  "start_%s = :s AND end_%s = :e", dateColumn, dateColumn);
      }
      else
      {
	 sprintf (valuesStatement, 
		  "VALUES (%d, to_date (:a, 'dd-mon-yyyy hh24:mi:ss'), to_date (:b, 'dd-mon-yyyy hh24:mi:ss'), :c, %d)",
		  siteDatatypeId, runControl.modelOrSourceId);
	 sprintf (whereStatement, 
		  "start_%s = to_date (:s, 'dd-mon-yyyy hh24:mi:ss') AND end_%s = to_date (:e, 'dd-mon-yyyy hh24:mi:ss')", dateColumn, dateColumn);
      }
    }

  sprintf (insertStatement, "INSERT INTO %s %s", runControl.tableDest, 
	   valuesStatement);

  if (!runControl.isStat)
  {
  /* OVERWRITE - set it here if it's variable !*/
     if (!runControl.destIsRange)
	sprintf (updateStatement, "UPDATE %s SET value = :v WHERE site_datatype_id = %d AND %s", runControl.tableDest, 
		 siteDatatypeId, whereStatement);
     else
	sprintf (updateStatement, "UPDATE %s SET value = :v, source_id = %d WHERE site_datatype_id = %d AND %s", runControl.tableDest, 
		 runControl.modelOrSourceId, siteDatatypeId, whereStatement);
  }
  else
    sprintf (updateStatement, "UPDATE %s SET value = :v, source_id = %d WHERE site_datatype_id = %d AND %s", runControl.tableDest, runControl.modelOrSourceId,
	     siteDatatypeId, whereStatement);
 
#ifdef DEBUG     
 fprintf (stdout, "Insert stmt: %s\n", insertStatement);
 fprintf (stdout, "Update stmt: %s\n", updateStatement);
#endif
 
 EXEC SQL PREPARE insert_vals FROM :insertStatement;
 if ((result = SqlErrorHandler 
      (FUNC_NAME, FALSE,
       "Problem preparing insert statement:\n\t%s",
       insertStatement)) != OK)
   {
     EXEC SQL ROLLBACK;
     return (ERROR);
   }
 
 EXEC SQL PREPARE update_vals FROM :updateStatement;
 if ((result = SqlErrorHandler 
      (FUNC_NAME, FALSE,
       "Problem preparing update statement:\n\t%s",
       updateStatement)) != OK)
   {
     EXEC SQL ROLLBACK;
     return (ERROR);
   }
 
 for (valueCount = 0; valueCount < numDisAggValues; valueCount++)
   {
     value = disAggValueList[valueCount].value;

     /* Try first to update an appropriate record */
     if (!runControl.destIsRange)
       {
	 if (!runControl.isStat)
	   {
	     strcpy (date1, disAggValueList[valueCount].dateStart);
	     strcpy (date2, disAggValueList[valueCount].dateEnd);
	     EXEC SQL EXECUTE update_vals
		USING :value, :date1, :date2;
	   }
	 else
	   {
	     index1 = disAggValueList[valueCount].timeIndexStart;
	     EXEC SQL EXECUTE update_vals
	       USING :value, :index1;
	   }
       }
     else
	/* never find this case currently; all range-only tables are m_;
	 would need to change the update statement if this did occur;
	 current one won't work */
	 if (!runControl.isStat)
	   {
	     strcpy (date1, disAggValueList[valueCount].dateStart);
	     strcpy (date2, disAggValueList[valueCount].dateEnd);
	     EXEC SQL EXECUTE update_vals
	       USING :value, :date1, :date2;
	   }
	 else
	   {
	     index1 = disAggValueList[valueCount].timeIndexStart;
	     index2 = disAggValueList[valueCount].timeIndexEnd;
	     EXEC SQL EXECUTE update_vals
	       USING :value, :index1, :index2;
	   }
       
     /* If no rows processed, insert row */
     if (sqlca.sqlcode > 0)
       {
	 if (!runControl.destIsRange)
	   {
	     if (!runControl.isStat)
	       EXEC SQL EXECUTE insert_vals USING :date1, :date2, :value;
	     else
	       EXEC SQL EXECUTE insert_vals USING :index1, :value;
	   }
	 else
	   {
	     if (!runControl.isStat)
	       EXEC SQL EXECUTE insert_vals USING :date1, :date2, :value;
	     else
	       EXEC SQL EXECUTE insert_vals USING :index1, :index2, :value;
	   }

	 if ((result = SqlErrorHandler 
	      (FUNC_NAME, FALSE,
	       "Problem inserting value for SDI: %d, record: %d into %s.\n\tExiting.", 
	       siteDatatypeId, valueCount, runControl.tableDest)) != OK)
	   {
	     EXEC SQL ROLLBACK;
	     return (ERROR);
	   }
       }

     /* Make sure no error on update */
     else
       {
	 if ((result = SqlErrorHandler 
	      (FUNC_NAME, FALSE,
	       "Problem updating value for SDI: %d, record: %d into %s.\n\tExiting.", sdi, valueCount, runControl.tableDest)) != OK)
	   {
	     EXEC SQL ROLLBACK;
	     return (ERROR);
	   }
       }
   }
 
  EXEC SQL COMMIT;	
  return (OK);
}

/***************************************************************************/
#define FUNC_NAME "SqlWriteModelAggDisagg"

int SqlWriteModelAggDisagg (RUN_CONTROL runControl, ID siteDatatypeId,
			    VALUE_RECORD *disAggValueList, int numDisAggValues)

{
  EXEC SQL BEGIN DECLARE SECTION;
    SQL_DATE      date1;
    SQL_DATE      date2;
    int           index1;
    int           index2;
    double        value;
    char          insertStatement[1000];
    char          updateStatement[1000];
    ID            sdi;
 EXEC SQL END DECLARE SECTION;

  int         valueCount,
              result;
  char        dateColumn[30],
              valuesStatement[200],
              whereStatement[200];
  
  /* Set date column based on destination interval. */
  if ((result = GetDateColumn (runControl.obsDest, runControl.isStat,
			       runControl.destIsRange, dateColumn)) != OK)
    {
      PrintError ("%s: Exiting.\n", FUNC_NAME);
      return (ERROR);
    }

  if (!runControl.destIsRange)
    {
      if (runControl.isStat)
      {
	 sprintf (valuesStatement, 
		  "VALUES (%d, %d, :a, :b)",
		  runControl.modelOrSourceId, siteDatatypeId);
	 sprintf (whereStatement, "%s = :d", dateColumn);
      }
      else
      {
	 sprintf (valuesStatement, 
		  "VALUES (%d, %d, to_date (:a, 'dd-mon-yyyy hh24:mi:ss'), to_date (:b, 'dd-mon-yyyy hh24:mi:ss'), :c)",
		  runControl.modelOrSourceId, siteDatatypeId);
	 sprintf (whereStatement, "start_%s = to_date (:d, 'dd-mon-yyyy hh24:mi:ss') AND end_%s = to_date (:e, 'dd-mon-yyyy hh24:mi:ss')", 
		  dateColumn, dateColumn);
      }
    }
  else
    {
      if (runControl.isStat)
      {
	 sprintf (valuesStatement, 
		  "VALUES (%d, %d, :a, :b, :c)",
		  runControl.modelOrSourceId, siteDatatypeId);
	 sprintf (whereStatement, 
		  "start_%s = :s AND end_%s = :e", dateColumn, dateColumn);
      }
      else
      {
	 sprintf (valuesStatement, 
		  "VALUES (%d, %d, to_date (:a, 'dd-mon-yyyy hh24:mi:ss'), to_date (:b, 'dd-mon-yyyy hh24:mi:ss'), :c)",
		  runControl.modelOrSourceId, siteDatatypeId);
	 sprintf (whereStatement, 
		  "start_%s = to_date (:s, 'dd-mon-yyyy hh24:mi:ss') AND end_%s = to_date (:e, 'dd-mon-yyyy hh24:mi:ss')", dateColumn, dateColumn);
      }
    }

  sprintf (insertStatement, "INSERT INTO %s %s", runControl.tableDest, 
	   valuesStatement);

  sprintf (updateStatement, "UPDATE %s SET value = :v WHERE model_run_id = %d AND site_datatype_id = %d AND %s", runControl.tableDest,
	   runControl.modelOrSourceId, siteDatatypeId, whereStatement);
 
#ifdef DEBUG     
 fprintf (stdout, "Insert stmt: %s\n", insertStatement);
 fprintf (stdout, "Update stmt: %s\n", updateStatement);
#endif
 
 EXEC SQL PREPARE insert_vals FROM :insertStatement;
 if ((result = SqlErrorHandler 
      (FUNC_NAME, FALSE,
       "Problem preparing insert statement:\n\t%s",
       insertStatement)) != OK)
   {
     EXEC SQL ROLLBACK;
     return (ERROR);
   }
 
 EXEC SQL PREPARE update_vals FROM :updateStatement;
 if ((result = SqlErrorHandler 
      (FUNC_NAME, FALSE,
       "Problem preparing update statement:\n\t%s",
       updateStatement)) != OK)
   {
     EXEC SQL ROLLBACK;
     return (ERROR);
   }
 
 for (valueCount = 0; valueCount < numDisAggValues; valueCount++)
   {
     value = disAggValueList[valueCount].value;

     /* Try first to update an appropriate record */
     if (!runControl.destIsRange)
       {
	  if (!runControl.isStat)
	  {
	     strcpy (date1, disAggValueList[valueCount].dateStart);
	     strcpy (date2, disAggValueList[valueCount].dateEnd);
	     EXEC SQL EXECUTE update_vals
		USING :value, :date1, :date2;
	  }
	  else
	  {
	     index1 = disAggValueList[valueCount].timeIndexStart;
	     EXEC SQL EXECUTE update_vals
		USING :value, :index1;
	  }
       }
     else
     {
	if (!runControl.isStat)
	{
	   strcpy (date1, disAggValueList[valueCount].dateStart);
	   strcpy (date2, disAggValueList[valueCount].dateEnd);
	   EXEC SQL EXECUTE update_vals
	      USING :value, :date1, :date2;
	}
	else
	  {
	     index1 = disAggValueList[valueCount].timeIndexStart;
	     index2 = disAggValueList[valueCount].timeIndexEnd;
	     EXEC SQL EXECUTE update_vals
		USING :value, :index1, :index2;
	  }
     }
       
     /* If no rows processed, insert row */
     if (sqlca.sqlcode > 0)
       {
	 if (!runControl.destIsRange)
	 {
	    if (!runControl.isStat)	
	       EXEC SQL EXECUTE insert_vals USING :date1, :date2, :value;
	    else
	       EXEC SQL EXECUTE insert_vals USING :index1, :value;
	 }
	 else
	 {
	    if (!runControl.isStat)	
	       EXEC SQL EXECUTE insert_vals USING :date1, :date2, :value;
	    else
	       EXEC SQL EXECUTE insert_vals USING :index1, :index2, :value;
	 }

     
	 if ((result = SqlErrorHandler 
	      (FUNC_NAME, FALSE,
	       "Problem inserting value for SDI: %d, record: %d into %s.\n\tExiting.", 
	       siteDatatypeId, valueCount, runControl.tableDest)) != OK)
	   {
	     EXEC SQL ROLLBACK;
	     return (ERROR);
	   }
       }

     /* Make sure no error on update */
     else
       {
	 if ((result = SqlErrorHandler 
	      (FUNC_NAME, FALSE,
	       "Problem updating value for SDI: %d, record: %d into %s.\n\tExiting.", sdi, valueCount, runControl.tableDest)) != OK)
	   {
	     EXEC SQL ROLLBACK;
	     return (ERROR);
	   }
       }
   }
 
  EXEC SQL COMMIT;	
  return (OK);
}








